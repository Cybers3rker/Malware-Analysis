**Executive Summary: x86 Architecture Fundamentals**

Executing binary code in x86 architecture relies on key components: CPU instructions for data manipulation, conditional jumps for program flow control, arithmetic operations, stack management via push/pop instructions, function calls using call/ret instructions, and memory registers for communication between CPU and memory. Understanding these basics is crucial for effective programming and system optimization.

For binary to execute in x86 architecture, we need to observe 3 things.
![[Pasted image 20240523071030.png]]
CPU Instructions:
![[Pasted image 20240523071100.png]]
Data is written from right to left. For instance:
Mov (move), edx (destination), eax (source)
This translates into Move (because the instruction comes first), followed by eax into edx.
![[Pasted image 20240523071505.png]]


The Jmp instruction is useful if you need the program to jump to one location or another, if a conditional is met. For instance, Jnz would translate to jump if not zero. If the value is true, we would jmp to one part of the program, and if it is false, we would jump somewhere else. If it is zero then go right, if it is 1 then go left.
![[Pasted image 20240523072312.png]]


The Arithmetic works exactly how you think they would. You can subtract numbers from other numbers, and even locations from other locations. 

Push and Pop are how we interact with the Stack. The stack is a place with memory where you can store information you need consistent access to. Stacks grow downwards, so the top of the stack is going to be the highest location. 
![[Pasted image 20240523073218.png]]
Let's say we want to call a function and set up the variables for said function. We will push those variables into the stack. 
Let's push 0, string, 12.
![[Pasted image 20240523073602.png]]
When we are done with these variables, we can POP them off of the stack. What this does is remove the lowest part of the stack that has information on it. 
![[Pasted image 20240523073843.png]]
Pop!
![[Pasted image 20240523073907.png]]
and so forth.
![[Pasted image 20240523074004.png]]

Let's take a look at two more additional instructions called Call and Ret.
![[Pasted image 20240523074139.png]]
Every function in the program is going to be called from the main method. For instance, when the main function starts, a bunch of variables will be introduced, then a call function will do something, and return back to the main method. 
![[Pasted image 20240523074902.png]]
What if you need to make a call within a call?
![[Pasted image 20240523075656.png]]
And I need to be able to go back to where the pickup milk function is once I am done helping the woman cross the street. Well, the location grab milk is saved in the extended base pointer (EBP). 
![[Pasted image 20240523080232.png]]

Let's take a look at our final section and learn about memory registers.
![[Pasted image 20240523080616.png]]
- EAX : Accumulator Register
- EDX:  Data Register
- EBX: Base Register
- ESP: Extended Stack Pointer
- EBP: Extended Base Pointer
- EIP: Extended Instruction Pointer
The communication from the CPU to the Stack is facilitated by those memory registers. 
![[Pasted image 20240523081151.png]]

Thank you for taking the time to read. Appreciate the support. 
